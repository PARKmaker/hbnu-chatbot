{
  "version": "KorQuAD_v1.0_dev",
  "data": [
    {
      "paragraphs": [
        {
          "qas": [
            {
              "answers": [
                {
                  "text": "서버에 쓸데 없는 부하가 많이 생기며 매번의 request마다 페이지를 새로 로드해야 한다.",
                  "answer_start": 95
                }
              ],
              "id": "1-1",
              "question": "서버에 단순히 request만 보내게 된다면 어떻게 되는가?"
            },
            {
              "answers": [
                {
                  "text": "단순히 서버에 request만 보내기 때문이다.",
                  "answer_start": 67
                }
              ],
              "id": "1-2",
              "question": "서버에 매번 request가 생기는 이유는?"
            },
            {
              "answers": [
                {
                  "text": "단순히 서버에 request만 계속 보내기 때문이다.",
                  "answer_start": 67
                }
              ],
              "id": "1-3",
              "question": "서버에 부하가 많이 생기는 이유는?"
            },
            {
              "answers": [
                {
                  "text": "서버에 쓸데없는 부하가 생긴다.",
                  "answer_start": 95
                }
              ],
              "id": "1-4",
              "question": "매번의 request마다 페이지를 새로 로드한다면?"
            },
            {
              "answers": [
                {
                  "text": "서버에서는 페이지 정보를 매번 클라이언트로 보내기 때문이다.",
                  "answer_start": 154
                }
              ],
              "id": "1-5",
              "question": "서버에 쓸데 없는 부하가 생기는 이유는?"
            },
            {
              "answers": [
                {
                  "text": "가질수 없다",
                  "answer_start": 256
                }
              ],
              "id": "1-6",
              "question": "웹은 실시간을 위해 지속되는 열결을 가질 수 있는가?"
            },
            {
              "answers": [
                {
                  "text": "응답하고 연결이 끊어진다.",
                  "answer_start": 282
                }
              ],
              "id": "1-7",
              "question": "웹은 클라이언트에서 서버에 접속하면 어떻게 되는가?"
            },
            {
              "answers": [
                {
                  "text": "대부분 실시간이 아니다.",
                  "answer_start": 339
                }
              ],
              "id": "1-8",
              "question": "웹에서 운용되는 실시간 서비스들은 실시간인가?"
            },
            {
              "answers": [
                {
                  "text": "클라이언트에서 서버에 접속하면 응답하고 연결이 끊어지기 때문이다",
                  "answer_start": 256
                }
              ],
              "id": "1-9",
              "question": "왜 웹에서 운용되는 서비스들은 대부분 실시간이 아닌가?"
            }
          ],
          "context": "웹 클라이언트에서 정보를 주고받는 방식은 여러가지가 있지만, 그중에서도 실시간 웹 통신은 매우 까다롭게 구성되어 있다. 단순히 서버에 request만 계속 보내게 된다면 서버에 쓸데 없는 부하도 많이 생길 것이고 만약에 매번의 request마다 페이지를 새로 로드해야 한다면 서버에서는 페이지 정보를 매번 클라이언트로 보내야하는 불상사가 발생할 수 있다. 웹은 태생 자체부터 실시간을 위해 필수적인 지속되는 연결(persistence connection)을 가질 수 없다. 클라이언트에서 서버에 접속하면 응답하고 연결이 끊어진다.(HTTP의 특징) 때문에 안타깝게도 현재 웹에서 운용되는 실시간 서비스들은 대부분 실시간이 아니다."
        },
        {
          "qas": [
            {
              "answers": [
                {
                  "text": "하나의 장치가 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식을 말한다.",
                  "answer_start": 14
                }
              ],
              "id": "1-10",
              "question": "폴링이란?"
            },
            {
              "answers": [
                {
                  "text": "폴링",
                  "answer_start": 0
                }
              ],
              "id": "1-11",
              "question": "일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식은?"
            },
            {
              "answers": [
                {
                  "text": "연결이 close를 호출되기 전까지 유지되지만 웹상의 HTTP에서는 연결이 유지되지 않는다.",
                  "answer_start": 119
                }
              ],
              "id": "1-12",
              "question": "일반적인 소켓들의 연결 유지상태는?"
            },
            {
              "answers": [
                {
                  "text": "유지되지 않는다.",
                  "answer_start": 162
                }
              ],
              "id": "1-13",
              "question": "일반적인 소켓들은 웹상의 HTTP에서는 연결이 유지되는가?"
            },
            {
              "answers": [
                {
                  "text": "유지된다.",
                  "answer_start": 139
                }
              ],
              "id": "1-14",
              "question": "일반적인 소켓들은 그 연결이 close를 호출되기 전까지 유지 되는가?"
            },
            {
              "answers": [
                {
                  "text": "서버에서 클라이언트로 데이터를 보내고 싶을 경우 클라이언트의 요청을 기다려야한다.",
                  "answer_start": 178
                }
              ],
              "id": "1-15",
              "question": "이로인해 서버는 어떤 문제가 생기는가?"
            },
            {
              "answers": [
                {
                  "text": "데이터를 클라이언트에 보낼 수 없다.",
                  "answer_start": 244
                }
              ],
              "id": "1-16",
              "question": "서버가 임의로 할수 없는것은?"
            },
            {
              "answers": [
                {
                  "text": "Polling이다",
                  "answer_start": 308
                }
              ],
              "id": "1-17",
              "question": "서버가 임의로 데이터를 클라이언트에 보내기 위해서는?"
            },
            {
              "answers": [
                {
                  "text": "클라이언트 입장에서 서버에 주기적으로 Request를 보내는 것이다.",
                  "answer_start": 328
                }
              ],
              "id": "1-18",
              "question": "Polling은 무엇인가요?"
            },
            {
              "answers": [
                {
                  "text": "빈 응답을 한다.",
                  "answer_start": 431
                }
              ],
              "id": "1-19",
              "question": "서버에 특정 event가 발생하지 않은 경우?"
            },
            {
              "answers": [
                {
                  "text": "그 직후에 들어오는 요청에 데이터를 담아 보낸다.",
                  "answer_start": 456
                }
              ],
              "id": "1-20",
              "question": "빈 응답을 하고 특정 Event가 발생했다면?"
            },
            {
              "answers": [
                {
                  "text": "클라이언트가 요청을 보냈을 때 그 요청에 대한 연결을 서버가 Event 발생할 때까지 가지고 있는 것이다.",
                  "answer_start": 501
                }
              ],
              "id": "1-21",
              "question": "Long Polling은 무엇인가요?"
            },
            {
              "answers": [
                {
                  "text": "그제야 응답을 보내는 것으로 이해한다",
                  "answer_start": 663
                }
              ],
              "id": "1-22",
              "question": "Long Polling은 서버입장에서 클라이언트의 요청을 가지고 있다가 특정 Event가 발생하면?"
            }
          ],
          "context": "폴링(polling)이란 하나의 장치(또는 프로그램)가 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치(또는 프로그램)의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식을 말한다. 일반적인 소켓들은 그 연결이 close를 호출되기 전까지 유지되지만 웹 상의 HTTP에서는 연결이 유지되지 않는다. 이로 인해 서버에서 클라이언트로 데이터를 보내고 싶을 경우 클라이언트의 요청을 기다려야 하는 문제가 생긴다. 즉, 서버가 임의로 데이터를 클라이언트에 보낼 수 없는 것이다. 이를 해결하기 위해 Server Push의 효과를 낼 수 있는 방식이 Polling이다. Polling은 클라이언트 입장에서 서버에 주기적으로 Request를 보내는 것이다. 예를 들어, 클라이언트는 주기적으로 서버에 요청을 보낸다. 그리고 서버에 특정 event가 발생하지 않은 경우에는 빈 응답을 하고 특정 Event가 발생했다면 그 직후에 들어오는 요청에 데이터를 담아보내는 것이다. Long Polling은 클라이언트가 요청을 보냈을 때 그 요청에 대한 연결을 서버가 Event 발생할 때까지 가지고 있는 것이다. 즉 응답을 지연시키는 것.(혹은 timeout되면 응답을 보내고 연결을 종료한다.) Long Polling은 서버입장에서 클라이언트의 요청을 가지고 있다가 특정 Event가 발생하면 그제야 응답을 보내는 것으로 이해할 수 있다."
        },
        {
          "qas": [
            {
              "answers": [
                {
                  "text": "클라이언트와 서버 간에 연결을 지속시키는 것.",
                  "answer_start": 6
                }
              ],
              "id": "1-23",
              "question": "웹 소켓은 무엇인가?"
            },
            {
              "answers": [
                {
                  "text": "웹 소켓이다.",
                  "answer_start": 0
                }
              ],
              "id": "1-24",
              "question": "클라이언트와 서버 간에 연결을 지속시키는 것은?"
            },
            {
              "answers": [
                {
                  "text": "전이중 통신 채널이다.",
                  "answer_start": 62
                }
              ],
              "id": "1-25",
              "question": "웹 소켓은 하나의 TCP connection위에서 무엇을 제공하는가?"
            },
            {
              "answers": [
                {
                  "text": "웹 소켓이다.",
                  "answer_start": 34
                }
              ],
              "id": "1-26",
              "question": "하나의 TCP connection위에서 전이중 통신 채널을 제공하는 것은?"
            },
            {
              "answers": [
                {
                  "text": "사용자의 웹 브라우저에서 서버로 영구 양방향, 전이중 TCP 연결을 위한 통신 프로토콜이다.",
                  "answer_start": 95
                }
              ],
              "id": "1-27",
              "question": "웹 소켓은 어떤 프로토콜인가?"
            },
            {
              "answers": [
                {
                  "text": "영구 양방향이다.",
                  "answer_start": 113
                }
              ],
              "id": "1-28",
              "question": "웹소켓은 사용자의 웹 브라우저와 서버에서 어떤 방향인가?"
            },
            {
              "answers": [
                {
                  "text": "웹 소켓 핸드셰이크 요청을 브라우저의 HTTP 연결에서 서버로 전송하여 연결을 업그레이드함으로써 시작.",
                  "answer_start": 156
                }
              ],
              "id": "1-29",
              "question": "웹 소켓 연결 어떻게 시작되는가?"
            },
            {
              "answers": [
                {
                  "text": "64비트 Sec-WebSocket-Key 헤더가 포함됩니다.",
                  "answer_start": 244
                }
              ],
              "id": "1-30",
              "question": "업그레이드 요청 헤더와 함께 핸드셰이크 요청에는 어떤 것이 포함되는가?"
            },
            {
              "answers": [
                {
                  "text": "키의 해시로 응답",
                  "answer_start": 306
                }
              ],
              "id": "1-31",
              "question": "서버는 Sec-Websocket-Auth 헤더에서 어떤 것을 응답하는가?"
            },
            {
              "answers": [
                {
                  "text": "캐싱 프록시이다.",
                  "answer_start": 329
                }
              ],
              "id": "1-32",
              "question": "이전 웹소켓 교환을 다시 못하게 하는 것은?"
            },
            {
              "answers": [
                {
                  "text": "이진이며 HTTP 프로토콜을 준수하지 않습니다.",
                  "answer_start": 382
                }
              ],
              "id": "1-33",
              "question": "이 시점부터 연결은 어떤 특성이 있나요?"
            },
            {
              "answers": [
                {
                  "text": "서버 또는 사용자는 서버 중 하나가 세션을 닫을 때까지 언제든지",
                  "answer_start": 481
                }
              ],
              "id": "1-34",
              "question": "웹 소켓이 열린 상태로 유지될 때 언제까지 메시지를 보낼 수 있는가?"
            },
            {
              "answers": [
                {
                  "text": "어느 한쪽 끝에서 시작 될 수있다.",
                  "answer_start": 537
                }
              ],
              "id": "1-35",
              "question": "통신은 어느 쪽에서 시작 될 수 있나요?"
            },
            {
              "answers": [
                {
                  "text": "이벤트 중심의 웹 프로그래밍을 가능하게 한다.",
                  "answer_start": 562
                }
              ],
              "id": "1-36",
              "question": "통신이 어느 한쪽 끝에서 시작될 수 있다면?"
            },
            {
              "answers": [
                {
                  "text": "클라이언트-서버 간 커넥션을 유지하기 때문에 이벤트를 주고받을 때",
                  "answer_start": 640
                }
              ],
              "id": "1-37",
              "question": "웹 소켓은 어떤 때에 실시간성을 보장할 수 있나요?"
            },
            {
              "answers": [
                {
                  "text": "대용량 트래픽에서는 서버가 클라이언트 수만큼의 연결을 유지해야 한다.",
                  "answer_start": 699
                }
              ],
              "id": "1-38",
              "question": "웹 소켓을 사용하면서 생기는 부담은?"
            }
          ],
          "context": "웹 소켓은 클라이언트와 서버 간에 연결을 지속시키는 것이다. 웹 소켓은 하나의 TCP connection위에서 전이중 통신 채널을 제공한다. 웹소켓(WebSocket)은 사용자의 웹 브라우저에서 서버로 영구 양방향, 전이중 TCP 연결을 위한 통신 프로토콜이다. 웹 소켓 연결은 웹 소켓 핸드셰이크 요청을 브라우저의 HTTP 연결에서 서버로 전송하여 연결을 업그레이드함으로써 시작됩니다. 업그레이드 요청 헤더와 함께 핸드셰이크 요청에는 64비트 Sec-WebSocket-Key 헤더가 포함됩니다. 서버는 Sec-Websocket-Auth 헤더에서 키의 해시로 응답합니다. 이 헤더 교환은 캐싱 프록시가 이전 WebSocket 교환을 다시 보내지 못하도록 합니다. 이 시점부터 연결은 이진이며 HTTP 프로토콜을 준수하지 않습니다. 서버 응용 프로그램은 모든 웹 소켓 연결을 인식하고 각 연결과 개별적으로 통신할 수 있습니다. 웹 소켓이 열린 상태로 유지되므로 서버 또는 사용자는 서버 중 하나가 세션을 닫을 때까지 언제든지 메시지를 보낼 수 있습니다. 통신은 어느 한쪽 끝에서 시작될 수 있으며, 이것은 이벤트 중심의 웹 프로그래밍을 가능하게 한다. 반면 표준 HTTP는 사용자만 새 데이터를 요청할 수 있도록 허용합니다. 정리하면 웹 소켓은 클라이언트-서버 간 커넥션을 유지하기 때문에 이벤트를 주고받을 때 실시간성을 보장할 수 있습니다. 하지만 대용량 트래픽에서는 서버가 클라이언트 수만큼의 연결을 유지해야 한다는 부담이 있습니다."
        }
      ],
      "title": "웹"
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "answers": [
                {
                  "text": "객체 기반의 스크립트 프로그래밍 언어이다.",
                  "answer_start": 8
                }
              ],
              "id": "2-1",
              "question": "자바스크립트란?"
            },
            {
              "answers": [
                {
                  "text": "웹 브라우저 내에서 주로 사용된다.",
                  "answer_start": 38
                }
              ],
              "id": "2-2",
              "question": "자바스크립트는 어디에서 사용되는가?"
            },
            {
              "answers": [
                {
                  "text": "다른 응용 프로그램의 내장 객체에도 접근할 수 있다.",
                  "answer_start": 58
                }
              ],
              "id": "2-3",
              "question": "자바스크립트는 어디에도 접근할 수 있는가?"
            },
            {
              "answers": [
                {
                  "text": "본래 넷스케이프 커뮤니케이션즈 코퍼레이션의 브렌던아이크가 처음에는 모카라는 이름으로, 나중에는 라이브스크립트라는 이름으로 개발하였으며, 최종적으로 자바스크립트가 되었다.",
                  "answer_start": 162
                }
              ],
              "id": "2-4",
              "question": "자바스크립트의 이름의 유래는?"
            },
            {
              "answers": [
                {
                  "text": "두 언어 모두 C언어의 기본 구문에 바탕을 뒀기 때문이고, 자바와 자바스크립트는 직접적인 연관성은 약하다.",
                  "answer_start": 281
                }
              ],
              "id": "2-5",
              "question": "자바스크립트와 자바의 차이점은?"
            },
            {
              "answers": [
                {
                  "text": "C언어의 기본 구문에 바탕을 뒀다.",
                  "answer_start": 0
                }
              ],
              "id": "2-6",
              "question": "자바스크립트는 어떤 구문을 바탕에 뒀는가?"
            },
            {
              "answers": [
                {
                  "text": "ECMA스크립트의 표준 사양을 가장 잘 구현한 언어다.",
                  "answer_start": 349
                }
              ],
              "id": "2-7",
              "question": "자바스크립트는 어떤 표준 사양을 가장 잘 구현 했는가?"
            },
            {
              "answers": [
                {
                  "text": "브라우저 호환성을 위해 트랜스파일러로 컴파일된다.",
                  "answer_start": 441
                }
              ],
              "id": "2-8",
              "question": "ECMA스크립트는 어떤 것으로 컴파일 되는가?"
            }
          ],
          "context": "자바스크립트 : 객체 기반의 스크립트 프로그래밍 언어이다. 자바스크립트는 웹 브라우저 내에서 주로 사용되며, 다른 응용 프로그램의 내장 객체에도 접근할 수 있는 기능을 가지고 있다. Node.js와 같은 런타임 환경과 같이 서버 프로그래밍에도 사용되고 있다. 자바스크립트의 이름의 유래 : 본래 넷스케이프 커뮤니케이션즈 코퍼레이션의 브렌던아이크가 처음에는 모카라는 이름으로, 나중에는 라이브스크립트라는 이름으로 개발하였으며, 최종적으로 자바스크립트가 되었다. 자바스크립트와 자바의 차이점 : 이는 사실 두 언어 모두 C언어의 기본 구문에 바탕을 뒀기 때문이고, 자바와 자바스크립트는 직접적인 연관성은 약하다. 자바스크립트는 ECMA스크립트의 표준 사양을 가장 잘 구현한 언어로 인정받고 있으며 ECMA스크립트5까지는 대부분의 브라우저에서 기본적으로 지원되었으나 ECMA스크립트 이후부터는 브라우저 호환성을 위해 트랜스파일러로 컴파일된다."
        }
      ],
      "title": "자바스크립트"
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "answers": [
                {
                  "text": "우연 또는 의도적으로 허가받지 않은 정보의 노출, 전송, 수정, 변조, 파괴 등으로 부터의 보호하는것이다.",
                  "answer_start": 7
                }
              ],
              "id": "3-1",
              "question": "정보보호란?"
            },
            {
              "answers": [
                {
                  "text": "수동적 공격과 능동적 공격으로 나눌 수 있다.",
                  "answer_start": 128
                }
              ],
              "id": "3-2",
              "question": "송신자와 수신자의 전송에서 공격하는 종류는?"
            },
            {
              "answers": [
                {
                  "text": "데이터(메세지)에 대한 변조(modification), 삽입(insertion), 삭제(deletion), 재생(replay) 등으로 여러 형태로 나타난다.",
                  "answer_start": 169
                }
              ],
              "id": "3-3",
              "question": "보안에 대한 공격으로 무엇이 있는가?"
            },
            {
              "answers": [
                {
                  "text": "Interception",
                  "answer_start": 266
                }
              ],
              "id": "3-4",
              "question": "소극적 공격은 무엇이 있는가?"
            },
            {
              "answers": [
                {
                  "text": "신분위장, 재전송, 메시지 수정, 서비스 거부가 있다.",
                  "answer_start": 289
                }
              ],
              "id": "3-5",
              "question": "적극적 공격은 무엇이 있는가?"
            },
            {
              "answers": [
                {
                  "text": "수동적 공격과 능동적 공격으로 분류될 수 있으며",
                  "answer_start": 324
                }
              ],
              "id": "3-6",
              "question": "공격 어떻게 분류되는가?"
            },
            {
              "answers": [
                {
                  "text": "전수공격, 중간자 공격 등이 있다.",
                  "answer_start": 363
                }
              ],
              "id": "3-7",
              "question": "현대 정보보호에서는 어떤 공격이 있는가?"
            },
            {
              "answers": [
                {
                  "text": "비밀성, 무결성, 가용성이 있다.",
                  "answer_start": 397
                }
              ],
              "id": "3-8",
              "question": "정보보호의 기본 목표는?"
            },
            {
              "answers": [
                {
                  "text": "정보는 소유자가 원하는대로 비밀이 유지되어야 한다.",
                  "answer_start": 422
                }
              ],
              "id": "3-9",
              "question": "비밀성이란?"
            },
            {
              "answers": [
                {
                  "text": "정보의 원형대로 보존되어야 한다.",
                  "answer_start": 422
                }
              ],
              "id": "3-10",
              "question": "무결성이란?"
            },
            {
              "answers": [
                {
                  "text": "필요로 할 때 언제든지 사용가능하다.",
                  "answer_start": 482
                }
              ],
              "id": "3-11",
              "question": "가용성이란?"
            }
          ],
          "context": "정보보호 : 우연 또는 의도적으로 허가받지 않은 정보의 노출, 전송, 수정, 변조, 파괴 등으로 부터의 보호하는것이다. 정보보호의 기능 : 기술적, 관리적(관리적, 운영적). 송신자와 수신자의 전송에서 공격하는 종류에 대하여서는 수동적 공격과 능동적 공격으로 나눌 수 있다. 또한 보안에 대한 공격으로 데이터(메세지)에 대한 변조(modification), 삽입(insertion), 삭제(deletion), 재생(replay) 등으로 여러 형태로 나타난다. 소극적 공격 : Interception. 적극적 공격 : 신분위장, 재전송, 메시지 수정, 서비스 거부가 있다. 공격은 수동적 공격과 능동적 공격으로 분류될 수 있으며, 현대 정보보호에서는 전수공격, 중간자 공격 등이 있다. 정보보호의 기본 목표로는 비밀성, 무결성, 가용성이 있다. 비밀성 : 정보는 소유자가 원하는대로 비밀이 유지되어야 한다. 무결성 : 정보의 원형대로 보존되어야 한다. 가용성 : 필요로 할 때 언제든지 사용가능하다."
        }
      ],
      "title": "정보보호"
    }
  ]
}